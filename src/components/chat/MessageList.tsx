import { AlertTriangle, Bot, Download, RefreshCw, ThumbsDown, ThumbsUp } from 'lucide-react';
import remarkGfm from 'remark-gfm';

import { useState } from 'react';
import ReactMarkdown from 'react-markdown';

import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

import { CopyToClipboard } from '../shared';
import { ChatAvatar } from './ChatAvatar';
import { ChatBubble } from './ChatBubble';
import CodeBlock from './CodeBlock';

interface Message {
  id: number;
  role: 'user' | 'assistant';
  content: string;
}

interface UsageMetadata {
  inputTokens?: number;
  outputTokens?: number;
  totalTokens?: number;
  latencyMs?: number;
  promptTokens?: number;
  completionTokens?: number;
}

interface MessageListProps {
  messages: Message[];
  streamingMessage?: Message | null;
  avatarInitials?: string;
  lastMessageMetadata?: UsageMetadata | null;
  onRegenerate?: (messageIndex: number) => void;
  isLoading?: boolean;
  onSavePrompt?: (content: string) => void;
}

// "Generated by AI" label component
const GenAiLabel = () => (
  <div className="flex items-center gap-1 text-xs text-muted-foreground">
    <Bot className="h-3 w-3" />
    <span>Generated by AI</span>
  </div>
);

const MessageList = ({
  messages,
  streamingMessage,
  avatarInitials = 'PC',
  lastMessageMetadata,
  onRegenerate,
  isLoading = false,
  onSavePrompt,
}: MessageListProps) => {
  const [messageFeedback, setMessageFeedback] = useState<Record<number, string>>({});
  const [regenerateModalVisible, setRegenerateModalVisible] = useState(false);
  const [pendingRegenerateIndex, setPendingRegenerateIndex] = useState<number | null>(null);

  // Calculate how many messages will be removed if regenerating at a given index
  const getMessagesToRemoveCount = (assistantIndex: number): number => {
    return messages.length - assistantIndex - 1;
  };

  const handleRegenerateClick = (index: number) => {
    const messagesToRemove = getMessagesToRemoveCount(index);

    if (messagesToRemove > 0) {
      // Show confirmation dialog if there are subsequent messages
      setPendingRegenerateIndex(index);
      setRegenerateModalVisible(true);
    } else {
      // No subsequent messages, regenerate directly
      onRegenerate?.(index);
    }
  };

  const handleRegenerateConfirm = () => {
    if (pendingRegenerateIndex !== null) {
      onRegenerate?.(pendingRegenerateIndex);
    }
    setRegenerateModalVisible(false);
    setPendingRegenerateIndex(null);
  };

  const handleRegenerateCancel = () => {
    setRegenerateModalVisible(false);
    setPendingRegenerateIndex(null);
  };

  const parseThinkingContent = (content: string) => {
    const thinkRegex = /<think>(.*?)<\/think>/s;
    const match = content.match(thinkRegex);

    if (match) {
      const thinkingContent = match[1].trim();
      const mainContent = content.replace(thinkRegex, '').trim();
      return { thinkingContent, mainContent };
    }

    return { thinkingContent: null, mainContent: content };
  };

  const handleFeedback = (messageId: number, feedbackType: string) => {
    setMessageFeedback((prev) => ({
      ...prev,
      [messageId]: feedbackType,
    }));
  };

  // Reusable markdown components configuration with table support
  const markdownComponents = {
    code: ({ className, children }: { className?: string; children?: React.ReactNode }) => {
      const inline = !className;
      const match = /language-(\w+)/.exec(className || '');
      const language = match ? match[1] : undefined;
      const codeString = String(children).replace(/\n$/, '');

      return !inline ? (
        <CodeBlock code={codeString} language={language} />
      ) : (
        <code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">{children}</code>
      );
    },
    table: ({ children }: { children?: React.ReactNode }) => (
      <div className="overflow-x-auto my-4">
        <table className="w-full border-collapse text-sm">{children}</table>
      </div>
    ),
    thead: ({ children }: { children?: React.ReactNode }) => (
      <thead className="bg-muted">{children}</thead>
    ),
    th: ({ children }: { children?: React.ReactNode }) => (
      <th className="border border-border px-3 py-2 text-left font-semibold">{children}</th>
    ),
    td: ({ children }: { children?: React.ReactNode }) => (
      <td className="border border-border px-3 py-2">{children}</td>
    ),
    tr: ({ children }: { children?: React.ReactNode }) => <tr>{children}</tr>,
  };

  // Find the last assistant message index
  const lastAssistantIndex = messages.reduce(
    (lastIdx, msg, idx) => (msg.role === 'assistant' ? idx : lastIdx),
    -1
  );

  return (
    <TooltipProvider>
      <div className="flex flex-col gap-6 max-w-4xl mx-auto">
        {messages.map((message, index) => (
          <div key={message.id} className="flex flex-col gap-1">
            <ChatBubble
              type={message.role === 'assistant' ? 'incoming' : 'outgoing'}
              ariaLabel={message.role === 'assistant' ? 'AI Assistant' : 'You'}
              avatar={
                <ChatAvatar
                  type={message.role === 'assistant' ? 'ai' : 'user'}
                  initials={avatarInitials}
                />
              }
              actions={
                message.role === 'assistant' ? (
                  <div className="flex items-center gap-1">
                    {/* Feedback dropdown */}
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon" className="h-7 w-7">
                          {messageFeedback[message.id] === 'helpful' ? (
                            <ThumbsUp className="h-3.5 w-3.5 fill-current" />
                          ) : messageFeedback[message.id] === 'not-helpful' ? (
                            <ThumbsDown className="h-3.5 w-3.5 fill-current" />
                          ) : (
                            <ThumbsUp className="h-3.5 w-3.5" />
                          )}
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="start">
                        <DropdownMenuItem
                          onClick={() => handleFeedback(message.id, 'helpful')}
                          disabled={messageFeedback[message.id] === 'helpful'}
                        >
                          <ThumbsUp className="h-4 w-4 mr-2" />
                          Helpful
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => handleFeedback(message.id, 'not-helpful')}
                          disabled={
                            messageFeedback[message.id] === 'not-helpful' ||
                            messageFeedback[message.id] === 'helpful'
                          }
                        >
                          <ThumbsDown className="h-4 w-4 mr-2" />
                          Not helpful
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>

                    {/* Copy button */}
                    <CopyToClipboard text={message.content} size="icon" className="h-7 w-7" />

                    {/* Regenerate button */}
                    {onRegenerate && (
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-7 w-7"
                            onClick={() => handleRegenerateClick(index)}
                            disabled={isLoading}
                          >
                            <RefreshCw className="h-3.5 w-3.5" />
                          </Button>
                        </TooltipTrigger>
                        <TooltipContent>Regenerate response</TooltipContent>
                      </Tooltip>
                    )}
                  </div>
                ) : (
                  <div className="flex items-center gap-1">
                    <CopyToClipboard text={message.content} size="icon" className="h-7 w-7" />
                    {onSavePrompt && (
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-7 w-7"
                            onClick={() => onSavePrompt(message.content)}
                          >
                            <Download className="h-3.5 w-3.5" />
                          </Button>
                        </TooltipTrigger>
                        <TooltipContent>Save prompt</TooltipContent>
                      </Tooltip>
                    )}
                  </div>
                )
              }
            >
              {message.role === 'assistant' ? (
                (() => {
                  const { thinkingContent, mainContent } = parseThinkingContent(message.content);
                  return thinkingContent ? (
                    <div className="flex flex-col gap-3">
                      <Accordion type="single" collapsible className="w-full">
                        <AccordionItem value="thinking" className="border-none">
                          <AccordionTrigger className="py-2 text-sm font-medium hover:no-underline">
                            Thinking Process
                          </AccordionTrigger>
                          <AccordionContent>
                            <ReactMarkdown
                              remarkPlugins={[remarkGfm]}
                              components={markdownComponents}
                            >
                              {thinkingContent}
                            </ReactMarkdown>
                          </AccordionContent>
                        </AccordionItem>
                      </Accordion>
                      <ReactMarkdown remarkPlugins={[remarkGfm]} components={markdownComponents}>
                        {mainContent}
                      </ReactMarkdown>
                    </div>
                  ) : (
                    <ReactMarkdown remarkPlugins={[remarkGfm]} components={markdownComponents}>
                      {mainContent}
                    </ReactMarkdown>
                  );
                })()
              ) : (
                <ReactMarkdown
                  remarkPlugins={[remarkGfm]}
                  components={{
                    ...markdownComponents,
                    p: ({ children }) => <>{children}</>,
                  }}
                >
                  {message.content}
                </ReactMarkdown>
              )}
            </ChatBubble>

            {/* Show metadata row after the last assistant message */}
            {message.role === 'assistant' && index === lastAssistantIndex && !streamingMessage && (
              <div className="pl-11 pt-1">
                <div className="flex flex-wrap items-center justify-between gap-2 text-xs text-muted-foreground">
                  <GenAiLabel />
                  {lastMessageMetadata && (
                    <div className="flex items-center gap-3">
                      {(lastMessageMetadata.inputTokens !== undefined ||
                        lastMessageMetadata.promptTokens !== undefined) && (
                        <span>
                          ↑ Input:{' '}
                          {(
                            lastMessageMetadata.inputTokens ?? lastMessageMetadata.promptTokens
                          )?.toLocaleString()}{' '}
                          tokens
                        </span>
                      )}
                      {(lastMessageMetadata.outputTokens !== undefined ||
                        lastMessageMetadata.completionTokens !== undefined) && (
                        <span>
                          ↓ Output:{' '}
                          {(
                            lastMessageMetadata.outputTokens ?? lastMessageMetadata.completionTokens
                          )?.toLocaleString()}{' '}
                          tokens
                        </span>
                      )}
                      {lastMessageMetadata.totalTokens !== undefined && (
                        <span>
                          + Total: {lastMessageMetadata.totalTokens.toLocaleString()} tokens
                        </span>
                      )}
                      {lastMessageMetadata.latencyMs !== undefined && (
                        <span>⏱ {lastMessageMetadata.latencyMs}ms</span>
                      )}
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>
        ))}

        {/* Streaming message */}
        {streamingMessage && (
          <ChatBubble
            type="incoming"
            ariaLabel="AI Assistant"
            avatar={<ChatAvatar type="ai" loading={true} />}
          >
            {streamingMessage.content ? (
              <div className="py-1">
                {(() => {
                  const { thinkingContent, mainContent } = parseThinkingContent(
                    streamingMessage.content
                  );
                  return (
                    <div className="flex flex-col gap-3">
                      {thinkingContent && (
                        <Accordion type="single" collapsible className="w-full">
                          <AccordionItem value="thinking" className="border-none">
                            <AccordionTrigger className="py-2 text-sm font-medium hover:no-underline">
                              Thinking Process
                            </AccordionTrigger>
                            <AccordionContent>
                              <ReactMarkdown
                                remarkPlugins={[remarkGfm]}
                                components={markdownComponents}
                              >
                                {thinkingContent}
                              </ReactMarkdown>
                            </AccordionContent>
                          </AccordionItem>
                        </Accordion>
                      )}
                      <ReactMarkdown remarkPlugins={[remarkGfm]} components={markdownComponents}>
                        {mainContent}
                      </ReactMarkdown>
                      <span className="inline-block w-2 h-4 bg-primary animate-pulse" />
                    </div>
                  );
                })()}
              </div>
            ) : (
              <span className="text-muted-foreground">Generating a response</span>
            )}
          </ChatBubble>
        )}

        {/* Regenerate Confirmation Dialog */}
        <Dialog open={regenerateModalVisible} onOpenChange={setRegenerateModalVisible}>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle>Regenerate response</DialogTitle>
              <DialogDescription>
                Regenerating this response will remove{' '}
                {pendingRegenerateIndex !== null && (
                  <strong>{getMessagesToRemoveCount(pendingRegenerateIndex)} message(s)</strong>
                )}{' '}
                that follow it.
              </DialogDescription>
            </DialogHeader>
            <div className="flex items-center gap-2 text-sm text-amber-600 dark:text-amber-500">
              <AlertTriangle className="h-4 w-4" />
              <span>This action cannot be undone.</span>
            </div>
            <DialogFooter className="gap-2 sm:gap-0">
              <Button variant="outline" onClick={handleRegenerateCancel}>
                Cancel
              </Button>
              <Button onClick={handleRegenerateConfirm}>Regenerate</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </TooltipProvider>
  );
};

export default MessageList;
